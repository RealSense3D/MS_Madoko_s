/*---------------------------------------------------------------------------
  Copyright 2013 Microsoft Corporation.
 
  This is free software; you can redistribute it and/or modify it under the
  terms of the Apache License, Version 2.0. A copy of the License can be
  found in the file "license.txt" at the root of this distribution.
---------------------------------------------------------------------------*/

// Parse Madoko markdown text.
module madoko

import std/dict
import std/regex
import common
import options
import block
import formatBlock
import inline
import formatInline
import definitions
import htmlFormatter    // for full
import texFormatter     // for full

/* --------------------------------------
  Main library entry point 
---------------------------------------- */

// Takes source markdown input and returns formatted html
public function markdown( src : string, options : options = initialOptions, fmt : formatter = FmtHtml ) : pure string
{
  if (options.xmp) then markdownXmp(src,options,fmt) else markdownNormal(src,options,fmt)
}

// Process only markdown between <xmp> tags 
function markdownXmp( src : string, options : options = initialOptions, fmt : formatter = FmtHtml ) : pure string
{
  src.replaceAll( rxxmp ) fun(cap) {
    // trace("xmp: " + cap.groups[1])
    markdownNormal(cap.groups[1],options,fmt)
  }
}
val rxxmp = regex(@"<xmp\b" + tagContent + @">([\s\S]*?)</xmp>")

public function normalizeSource( src : string ) : string {
  srcnl = if (src.contains('\r')) then src.replaceAll(regex(@"\r\n?"),"\n") else src
  srcnl.replaceAll(regex(@"\t"), "    ") 
}

// Takes source markdown input and returns formatted html
function markdownNormal( src0 : string, options0 : options = Options(), fmt : formatter = FmtHtml ) : pure string
{  
  // first normalize the input: all tabs to 4 spaces.
  val (options,src) = parseMeta(options0,src0.normalizeSource)

  if (options.verbose > 2) then trace("parse blocks")
  val blocks = parseBlocks(src,options.citestyle,options.bench,options.pedantic )
  
  // parse definitions
  val icontext  = inlineContext(fmt,options.metadata.dict,
                                    options.mathdim.parseMathDim(options.mathimg,options.mathScale), 
                                    options.citestyle,
                                    options.sanitize,options.bench,options.verbose,
                                    options.mathimg) 
  if (options.verbose > 2) then trace("process definitions")
  val (fblocks,fcontext) 
    = parseDefinitions(initialFormatContext(icontext,options.titleInfo,options.headingBase,options.pedantic,fmt), 
                        blocks,
                        options.metadata,
                        options.tocDepth)

  // parse inline elements
  if (options.verbose > 2) then trace("parse inline")
  body = //(if (options.autoCount) then "<!-- generated by MarkedX -->\n" else "") + 
         formatBlocks(fcontext,fblocks)
  if (options.verbose > 2) then trace("generate output")
  // generate full html/tex if needed
  xfull = if (!(options.bench || options.sanitize || options.full.isJust) &&
               ((options.title+options.scripts+options.htmlHeader+options.texHeader)!=""
                || options.css.splitPaths.length > 1 
                || options.packages.splitPaths.length > 1))
           then True else options.full.maybe(False,id) 

  res = if (xfull) 
         then (fmt.pick(fmtHtmlFull,fmtTexFull))(body,options)
         else body 
  if (options.verbose > 2) then trace("done")
  res           
}

function titleInfo( options : options ) : titleinfo {
  authors = zip(options.author.splitPaths, options.affiliation.splitPaths, options.email.splitPaths) 
  Titleinfo(options.title, options.subtitle, authors)
}

function zip(xs,ys,zs,acc=[]) : list<(string,string,string)> {
  match(xs) {
    Nil -> acc.reverse
    Cons(x,xx) -> match(ys) {
      Nil -> zip(xx,ys,zs,Cons((x,"",""),acc))
      Cons(y,yy) -> match(zs) {
        Nil -> zip(xx,yy,zs,Cons((x,y,""),acc))
        Cons(z,zz) -> zip(xx,yy,zz,Cons((x,y,z),acc))
      }
    }
  }
}


// Export initial options for JavaScript usage
public val initialOptions = Options()

public function traceRuleHist() {
  common/traceRuleHist()
}

// parse a dimension file written by latex snippets
function parseMathDim( txt : string, imgPrefix : string = ".", imgScale : int = 100 ) : dict<mathinfo> {
  mi = mdict()
  scale = imgScale.double / 100.0
  txt.findAll(rxDimLine).foreach fun(cap) {
    imageName = imgPrefix + "/eq-" + cap.groups[1] + ".png"
    height = scale * dimension(cap.groups[3],cap.groups[4])
    depth  = scale * dimension(cap.groups[5],cap.groups[6])
    width  = scale * dimension(cap.groups[7],cap.groups[8])
    mi[cap.groups[2]] := Mathinfo(imageName,height,depth,width,"")
  }
  return mi.freeze()
} 

val rxDimLine = regex(@"^(\d+) *, *([a-zA-Z0-9]+) *" + rxDim + rxDim + rxDim + "$", multiLine=True)
val rxDim = @", *(\d+)(?:\.(\d+))? *pt\b *"

function dimension( whole : string, fraction : string ) : double {
  w = whole.parseInt.maybe(0,id).double
  f = (fraction + "00").substr(0,2).parseInt.maybe(0,id).double / 100.0
  return (w+f)
}
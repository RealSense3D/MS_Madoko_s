/*---------------------------------------------------------------------------
  Copyright 2013 Microsoft Corporation.
 
  This is free software; you can redistribute it and/or modify it under the
  terms of the Apache License, Version 2.0. A copy of the License can be
  found in the file "license.txt" at the root of this distribution.
---------------------------------------------------------------------------*/

// Parse Madoko markdown text.
module madoko

import std/dict
import std/regex
import common
import options
import metadata
import block
import formatBlock
import inline
import formatInline
import definitions
import htmlFormatter    // for full
import texFormatter     // for full
import attributes       // expandKeys

/* --------------------------------------
  Main library entry point 
---------------------------------------- */

// Takes source markdown input and returns formatted html
public function markdown( src : string, options : options = initialOptions, fmt : formatter = FmtHtml ) : pure string
{
  if (options.xmp) then markdownXmp(src,options,fmt) else markdownNormal(src,options,fmt)
}

// Process only markdown between <xmp> tags 
function markdownXmp( src : string, options : options = initialOptions, fmt : formatter = FmtHtml ) : pure string
{
  src.replaceAll( rxxmp ) fun(cap) {
    // trace("xmp: " + cap.groups[1])
    markdownNormal(cap.groups[1],options,fmt)
  }
}
val rxxmp = regex(@"<xmp\b" + tagContent + @">([\s\S]*?)</xmp>")

public function normalizeSource( src : string ) : string {
  srcnl = if (src.contains('\r')) then src.replaceAll(regex(@"\r\n?"),"\n") else src
  srcnl.replaceAll(regex(@"\t"), "    ") 
}

// Takes source markdown input and returns formatted html
function markdownNormal( src0 : string, options0 : options = Options(), fmt : formatter = FmtHtml ) : pure string
{  
  // first normalize the input: all tabs to 4 spaces.
  val (options,src) = parseMeta(options0,fmt,src0.normalizeSource)

  if (options.verbose>=4) then trace("parse blocks")
  //val blocks = parseBlocks(src,options.citestyle,options.bench,options.pedantic )
  
  // parse definitions
  val icontext  = inlineContext(fmt,options.metadata.dict,
                                    options.mathdim, 
                                    options.citestyle,
                                    options.sanitize,options.bench,options.verbose,
                                    options.mathmode.isStatic,
                                    options.highlight) 
  //if (options.verbose > 2) then trace("process definitions")
  val (fblocks,boxes,fcontext) 
    = parseBody(initialFormatContext(icontext,options.titleInfo(icontext.metadata),
                                      options.headingBase,options.pedantic,fmt), 
                src,
                options.metadata, options.tocDepth,
                options.sectionBase,options.sectionMax)

  // parse inline elements
  if (options.verbose>=4) then trace("parse inline")
  body = //(if (options.autoCount) then "<!-- generated by MarkedX -->\n" else "") + 
         formatBlocks(fcontext,fblocks,boxes)
  if (options.verbose>=4) then trace("generate output")
  // generate full html/tex if needed
  xfull = if (!(options.bench || options.sanitize || options.full.isJust) &&
               ((options.title+options.scripts+options.htmlHeader+options.texHeader)!=""
                || options.css.splitPaths.length > 1 
                || options.packages.splitPaths.length > 1))
           then True else options.full.maybe(False,id) 

  res = if (xfull) 
         then (fmt.pick(fmtHtmlFull,fmtTexFull))(body,options,fcontext.inlineContext.metadata)
         else body 
  if (options.verbose>=4) then trace("done")
  res           
}

function titleInfo( options : options, metadata : dict<string> ) : titleinfo {
  function expand(s) { s.expandKeys(metadata) }  
  authors = zip(options.author.expand.splitPaths, options.affiliation.expand.splitPaths, 
                  options.email.expand.splitPaths) 
  Titleinfo(options.title.expand, options.subtitle.expand, authors, options.titleDate.expand)
}

function zip(xs,ys,zs,acc=[]) : list<(string,string,string)> {
  match(xs) {
    Nil -> acc.reverse
    Cons(x,xx) -> match(ys) {
      Nil -> zip(xx,ys,zs,Cons((x,"",""),acc))
      Cons(y,yy) -> match(zs) {
        Nil -> zip(xx,yy,zs,Cons((x,y,""),acc))
        Cons(z,zz) -> zip(xx,yy,zz,Cons((x,y,z),acc))
      }
    }
  }
}


// Export initial options for JavaScript usage
public val initialOptions = Options()

public function traceRuleHist() {
  common/traceRuleHist()
}

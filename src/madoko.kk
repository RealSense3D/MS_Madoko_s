/*---------------------------------------------------------------------------
  Copyright 2013 Microsoft Corporation.
 
  This is free software; you can redistribute it and/or modify it under the
  terms of the Apache License, Version 2.0. A copy of the License can be
  found in the file "license.txt" at the root of this distribution.
---------------------------------------------------------------------------*/

// Parse Madoko markdown text.
module madoko

import std/dict
import std/regex
import common
import options
import metadata
import block
import formatBlock
import inline
import formatInline
import definitions
import htmlFormatter    // for full
import texFormatter     // for full
import latexFormatter
import attributes       // expandKeys
import std/log

/* --------------------------------------
  Main library entry point 
---------------------------------------- */

// Takes source markdown input and returns formatted html
public function markdown( src : string, 
                          options : options = initialOptions0, 
                          fmt : formatter = FmtHtml 
                        ) : pure string
{
  if (options.xmp) then markdownXmp(src,options,fmt) else markdownNormal(src,options,fmt)
}

// Process only markdown between <xmp> tags 
function markdownXmp( src : string, options : options = initialOptions0, fmt : formatter = FmtHtml ) : pure string
{
  src.replaceAll( rxxmp ) fun(cap) {
    // trace("xmp: " + cap.groups[1])
    markdownNormal(cap.groups[1],options,fmt)
  }
}
val rxxmp = regex(@"<xmp\b" + tagContent + @">([\s\S]*?)</xmp>")

public function normalizeSource( src : string ) : string {
  val srcnl = if (src.contains('\r')) then src.replaceAll(regex(@"\r\n?"),"\n") else src
  srcnl.replaceAll(regex(@"\t"), "    ") 
}

// Takes source markdown input and returns formatted html
function markdownNormal( src0 : string, options0 : options = initialOptions0, fmt : formatter = FmtHtml ) : pure string
{  
  // first normalize the input: all tabs to 4 spaces.
  val (options1,src) = parseMeta(options0,fmt,src0.normalizeSource)
  val options = options1(metadata = options1.metadata.completeAuthorKeys)
  val xfull = options.full.maybe(True,id)     
  val logo  = if (xfull && options.logo) then "\n\n~Begin LogoMadoko\n&LogoMadoko;\n~End LogoMadoko\n" else "\n"
  
  if (options.verbose>=4) then trace("parse blocks")
  //val blocks = parseBlocks(src,options.citestyle,options.bench,options.pedantic )

  if (options.citeAll) then log("aux",@"\citation{*}");
  
  // parse definitions
  val icontext  = inlineContext(fmt,options.metadata.dict,
                                    options.mathdim,
                                    options.embedinfos, 
                                    options.citestyle,
                                    options.sanitize,options.bench,options.verbose,
                                    options.mathmode.isStatic,
                                    options.highlight,options.starBold,options.prettyAlign) 
  //if (options.verbose > 2) then trace("process definitions")
  val (fblocks,fcontext) 
    = parseBody(initialFormatContext(icontext,options.lineMap,
                                      options.headingBase,options.pedantic,fmt), 
                options.lineNo,
                src + logo,
                options.metadata, options.tocDepth,
                options.sectionBase,options.sectionMax)

  // parse inline elements
  if (options.verbose>=4) then trace("parse inline")
  val body = //(if (options.autoCount) then "<!-- generated by MarkedX -->\n" else "") + 
             formatBlocks(fcontext,fblocks)
  if (options.verbose>=4) then trace("generate output")

  // log links and labels
  if (fmt.isFmtHtml) {
    fcontext.inlineContext.labels.list().foreach fun(elem) {
      val (name,label) = elem
      log("labels","{ \"name\": " + name.json + ", \"text\": " + label.labelText.json + ", \"caption\": " + label.labelCaption.json + " }" );
    }
    fcontext.inlineContext.links.list().foreach fun(elem) {
      val (name,link) = elem
      log("links","{ \"name\": " + name.json + ", \"href\": " + link.href.json + ", \"title\": " + link.title.json + " }" );
    }
  }

  // generate full html/tex if needed
  val res = if (xfull) 
             then (fmt.pick(fmtHtmlFull,fmtTexFull))(body,options,fcontext.inlineContext.metadata)
             else body 
  // emit file references if necessary
  if (!xfull || !(fmt.isFmtHtml)) then fmtHtmlFull("",options,fcontext.inlineContext.metadata) else ""
  if (!xfull || !(fmt.isFmtTex))  then fmtTexFull("",options,fcontext.inlineContext.metadata) else ""
  
  if (options.verbose>=4) then trace("done")
  res           
}

function json(s : string) : string {
  val cs = s.list.map fun(c) {
    if (c=='\n') then "\\n"
    elif (c=='\r') then "\\r"
    elif (c=='\t') then "\\t"
    elif (c=='"') then "\\\""
    elif (c=='\\') then "\\\\"
    elif (c >= ' ' && c <= '~') then c.string
    else "\\u" + c.int.showHex(4)
  }
  return "\"" + cs.join + "\""
}


// Export initial options for JavaScript usage
public val initialOptions0 = initialOptions();

public function initialOptions() {
  return Options();
}

public function traceRuleHist() {
  common/traceRuleHist()
}




// Create an ":inlineContext"
function inlineContext( fmt : formatter, 
                               metadata : dict<string>,
                               mathinfos : dict<mathinfo>,
                               embedinfos : dict<embedinfo>,
                               citestyle : citestyle = citeAuto,
                               sanitize : bool = False,
                               bench: bool = False,
                               verbose : int = 0,
                               mathStatic : bool = False,
                               highlight : bool = True,
                               starBold : bool = False,
                               prettyAlign : int = 2 ) : inlineContext
{
  function pickx(f,g,h) {
    match(fmt) {
      FmtTex -> match(metadata["tex2"]) {
                  Just(value) | value.toLower == "true"  -> h
                  _ -> g
                }
      FmtHtml -> f
    }                
  }
  InlineContext( inlineGrammar(fmt,bench), dict(), dict(), dict(), dict(),
                 metadata, mathinfos, embedinfos,
                 citestyle, sanitize, bench, verbose, mathStatic, highlight, starBold, prettyAlign,
                 pickx(fmtHtmlCmd,fmtTexCmd,fmtLatexCmd), 
                 pickx(fmtHtmlEscape,fmtTexEscape,fmtLatexEscape), 
                 pickx(fmtHtmlLink,fmtTexLink,fmtLatexLink), 
                 pickx(fmtHtmlFootnote,fmtTexFootnote,fmtLatexFootnote),
                 pickx(fmtHtmlTable,fmtTexTable,fmtLatexTable),
                 pickx(fmtHtmlEnv,fmtTexEnv,fmtLatexEnv),
                 pickx(fmtHtmlCodePlain,fmtTexCodePlain,fmtLatexCodePlain),
                 pickx(fmtHtmlCodeHilite,fmtTexCodeHilite,fmtLatexCodeHilite),
                 pickx(fmtHtmlCodeToken,fmtTexCodeToken,fmtLatexCodeToken),
                 pickx(fmtHtmlLineInfo, fmtTexLineInfo, fmtLatexLineInfo),
                 pickx(fmtHtmlCodeTable, fmtTexCodeTable, fmtLatexCodeTable),
                 pickx(fmtLatexCmd,fmtTexCmd,fmtLatexCmd), // math cmd
                 pickx(fmtLatexEnv,fmtTexEnv,fmtLatexEnv), // math env
                 fmt 
               )
}

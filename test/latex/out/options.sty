%---------------------------------------------------------------------------
%  Copyright 2013 Microsoft Corporation.
% 
%  This is free software; you can redistribute it and/or modify it under the
%  terms of the Apache License, Version 2.0. A copy of the License can be
%  found in the file "license.txt" at the root of this distribution.
%---------------------------------------------------------------------------
\NeedsTeXFormat{LaTeX2e}[1995/12/01]

\ProvidesPackage{options}[2015/03/01, Daan Leijen, Provides convenient key-value option processing]
\RequirePackage{etoolbox}

% --------------------------------------------------------
% make the package robust agains catcode changes of = and ,
% --------------------------------------------------------
\edef\opt@restore@catcodes{%
  \catcode`\noexpand\=\the\catcode`\=\relax
  \catcode`\noexpand\,\the\catcode`\,\relax
  \let\noexpand\opt@catcodes\relax
}
\catcode`\=12\relax
\catcode`\,12\relax


% --------------------------------------------------------
% Extensions to etoolbox
% --------------------------------------------------------

\providerobustcmd*\@swaparg[2]{#2{#1}}
\providerobustcmd*\expandnext[2]{\expandafter\@swaparg\expandafter{#2}{#1}}

\providerobustcmd*\@swapx[2]{#2#1}
\providerobustcmd*\expandnextx[2]{\expandafter\@swapx\expandafter{#2}{#1}}


% expand a parameter-less definition once
\providerobustcmd\defexpandonce[1]{\edef#1{\expandafter\expandafter\expandafter\noexpand#1}}
% expand a parameter-less definition twice
\providerobustcmd\defexpandtwice[1]{\defexpandonce{#1}\defexpandonce{#1}}

\providerobustcmd*\eifstrequal[1]{\expandnext\ifstrequal{#1}}
\providerobustcmd*\eifblank[1]{\expandnext\ifblank{#1}}

\providerobustcmd*\ontoggle[2]{\iftoggle{#1}{#2}{}}

\providerobustcmd*\providelength[1]{\ifdef{#1}{}{\newlength#1}}
\providerobustcmd*\csnewlength[1]{\expandafter\newlength\csname #1\endcsname}
\providerobustcmd*\csprovidelength[1]{\ifcsdef{#1}{}{\expandafter\newlength\csname #1\endcsname}}
\providerobustcmd*\cssetlength[2]{\expandafter\setlength\csname #1\endcsname{#2}}


% --------------------------------------------------------
% Basic option commands
% \option{<key>} returns the value of a key
% \letoption{<key>}\cmd  let's \cmd to the value of <key>
% --------------------------------------------------------

\newcommand\option[1]{\csname optk@#1\endcsname}
\newrobustcmd*\letoption[2]{\expandafter\let\expandafter#2\csname optk@#1\endcsname}


% --------------------------------------------------------
% options, optionsalso
% main key setting routine
% --------------------------------------------------------

\newif\ifopt@ignoreunknown
\newif\ifopt@allowsearch


\newrobustcmd*\optionswithremaining{\@ifstar{\options@wrm{true}}{\options@wrm{false}}}
\newrobustcmd*\options@wrm[2]{%
  \letoptionlist{/options/remaining}\opt@savedremaining
  \options@normal{#1}{#2}%
  \expandnext\optionsalso{\opt@savedremaining}%
}

\newrobustcmd*\options{\@ifstar{\options@normal{true}}{\options@normal{false}}}
\newrobustcmd*\options@normal[2]{%
  \def\opt@defaultpath{/}%
  \opt@allowsearchtrue%
  \csname opt@ignoreunknown#1\endcsname%
  \option@setnil{/options/remaining}%
  \optionsalso{#2}%
}
\newrobustcmd*\optionsalso[1]{\opt@do#1,\opt@stop,}


% this is used if no argument is given
% define as relax, this makes it unique but also safe against infinite expansion
\def\optionnovalue{\relax}

% opt@stop is used to stop argument processing in tex \def's with patterns
\let\opt@stop\relax

% The main parsing of options
% This code is quite expanded to make it as efficient as possible.
% It is based on the original code by David Carlisle in the 
% standard latex "keyval" package.
\def\opt@do#1,{%
 \ifx\opt@stop#1\@empty\else
  \opt@split#1==\opt@stop
  \expandafter\opt@do\fi}

\def\opt@split#1=#2=#3\opt@stop{%
  \opt@spdef\optionrawpath{#1}%
  \ifx\optionrawpath\@empty\else
    % get value
    \ifx\@empty#3\@empty
      \let\optionvalue\optionnovalue
    \else
      \opt@spdef\optionvalue{#2}%
    \fi
    % try key directly
    \edef\optionpath{\optionrawpath}%
    \ifoptionisabsolute{\optionrawpath}%
      {\edef\optionpath{\optionrawpath}}% cannot let since optionrawpath may be a command
      {\edef\optionpath{\opt@defaultpath/\optionrawpath}}% use default path for relative keys
    \letoption\optionpath\opt@trykey
    %\typeout{try: \optionpath (\meaning\optionrawpath, \opt@defaultpath)}%
    \ifx\opt@trykey\relax
      % not directly found..
      \option@gethandler\optionpath% defines option@handlerkey & option@handler
      \ifx\option@handler\@empty
        % search key
        \ifopt@allowsearch
          \opt@searchalso{\optionpath}%
        \fi
      \else
        % handler
        \letoption{/handlers/\option@handler}\opt@trykey
        \ifx\opt@trykey\relax\else
          \edef\optionpath{/handlers/\option@handler}% will get \option@handlerkey
        \fi
      \fi
      \ifx\opt@trykey\relax
        % still not found: invoke unknown handler
        \ifopt@ignoreunknown
          \opt@collectunknown{#1}{#2}% expects \optionvalue to be defined
        \else
          \opt@unknown% expects \optionpath
        \fi
      \fi
    \fi
    % now \optionpath and \optionvalue are defined; invoke the /@code
    %\typeout{call \optionpath/@code }%
    \option{\optionpath/@code}%
    \ifx\option@handlernext\@empty\else
      \optionerror{handler ".\option@handlernext" cannot follow previous handlers}%
    \fi
  \fi
}

% Space gobbling; basically unchanged from the original definition in the keyval package by David Carlisle
% will take off one layer of braces
\newrobustcmd\opt@definespdef[1]{%
  \long\def\opt@spdef##1##2{%
    \futurelet\opt@firsttoken\opt@sp@a##2\opt@stop\opt@stop#1\opt@stop\relax##1}%
  \def\opt@sp@a{%
    \ifx\opt@firsttoken\opt@sptoken%
      \expandafter\opt@sp@b%
    \else%
      \expandafter\opt@sp@b\expandafter#1% add space token since sp@b removes one 
    \fi}%
  \long\def\opt@sp@b#1##1 \opt@stop{\opt@sp@c##1}%
}
\opt@definespdef{ }% define sp def with a space as argument
\newtoks\opt@temptoks% use a token register to maintain # arguments in values
\long\def\opt@sp@c#1\opt@stop#2\relax#3{\opt@temptoks{#1}\edef#3{\the\opt@temptoks}}
{\def\:{\global\let\opt@sptoken= } \: }



% search a key
\newrobustcmd*\opt@searchforkey[2]{%
  \option@ifisabsolute{#2}%
    \letoption{#2}\opt@trykey
    \ifx\opt@trykey\relax\else
      \edef\optionpath{#2}% found
    \fi
  \else  
    \letoption{#1#2}\opt@trykey% use default path
    \ifx\opt@trykey\relax
      \ifopt@allowsearch\else
        \opt@searchalso{#1#2}%
      \fi
    \else    
      \edef\optionpath{#1#2}% !found
    \fi
  \fi
}

% search an absolute key (and use searchalso too)
\newrobustcmd*\opt@searchforabskey[1]{%
  \letoption{#1}\opt@trykey
  \ifx\opt@trykey\relax
    \ifopt@allowsearch\else
      \opt@searchalso{#1}%
    \fi
  \else    
    \edef\optionpath{#1}% !found
  \fi
}

% \opt@searchalso: invoked to search for a key: set \opt@trykey and \optionpath if a match is found
%
% note: we can nest searches without grouping
% because they all use the same "\do" (option@searchalsodo) and
% all need to break once the inner one breaks (so it is fine if \opt@break redefined \do)
\newrobustcmd*\opt@searchalso[1]{%
  %\typeout{searchalso #1}%
  \let\do\opt@searchalsodo
  \option@foreachparent{#1}%
}
\newrobustcmd*\opt@searchalsodo[3]{% {<root>}{<subpath>}{<name>}
  \letoption{#1/.searchalso}\opt@temp
  \ifx\opt@temp\relax\else
    \edef\option@searchkey{#2#3}% subpath
    \opt@temp% invoke search routine
    \ifx\opt@trykey\relax\else\opt@break\fi% on found: break loop
  \fi
}

% invoked on unknown key: set \optionpath to the unknown handler (with option@unknownpath)
\newrobustcmd*\opt@unknown{%
  \def\do##1##2##3{%
    \letoption{##1/.unknown}\opt@temp
    \ifx\opt@temp\relax\else
      \edef\option@unknownpath{\optionpath}% full key
      \edef\option@unknownsubpath{##2##3}% subpath
      \edef\optionpath{##1/.unknown}%
      \opt@break%
    \fi%
  }
  \option@foreachparent{\optionpath}%

}

% invoked when unknown option needs to be saved (and ignored)
\newrobustcmd*\opt@collectunknown[2]{%
  \ifx\optionvalue\optionnovalue
    \option@push{/options/remaining}{#1}
  \else
    \option@push{/options/remaining}{#1={#2}}
  \fi
}

% \option@gethandler{key}: split off the part after the "/.", sets option@handlerkey and option@handler and option@handlernext
\def\option@gethandler#1{\expandafter\option@gethandler@#1/././.\opt@stop}
\def\option@gethandler@#1/.#2/.#3/.#4\opt@stop{%
  \def\option@handler{#2}%
  \ifx\option@handler\@empty\else
      \def\option@handlerkey{#1}%
      \def\option@handler{.#2}%
      \def\option@handlernext{#3}%
  \fi
}
\def\option@handlerkey{}
\def\option@handlernext{}

\newrobustcmd*\option@chainempty{%
  \let\optionvalue\optionnovalue
  \option@chainonly%
}
\newrobustcmd*\option@chainonly{%
  \ifx\option@handlernext\@empty\else
    \option@chain%
  \fi
}
\newrobustcmd*\option@chain{%
  \ifx\option@handlernext\@empty
    % we are done, invoke the option handler
    \let\optionpath\option@handlerkey%
    \option{\optionpath/@code}%
  \else
    % invoke the next handler
    %\typeout{call next handler: \option@handlerkey, \option@handlernext}%
    \edef\opt@temp{\option@handlerkey/.\option@handlernext}%
    \option@gethandler{\opt@temp}%
    \edef\optionpath{/handlers/\option@handler}%
    \letoption{\optionpath}\opt@trykey
    \ifx\opt@trykey\relax
      \opt@unknown% unknown handler; needs optionpath 
    \fi
    \option{\optionpath/@code}%
  \fi
}

% \option@isabsolute{key}: check if key starts with /
\def\ifoptionisabsolute#1{\expandafter\ifoptionisabsolute@#1/\opt@stop}
\def\ifoptionisabsolute@#1/#2\opt@stop{\def\opt@temp@abs{#1}\ifx\opt@temp@abs\@empty\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi}


% \option@splitroot{path}: split off the first directory of a path into \option@root 
% option@splitroot{/foo/bar} -> foo 
% option@splitroot{/foo}  -> foo
\newrobustcmd*\option@splitroot[1]{\expandafter\option@splitroot@#1//\opt@stop}
\def\option@splitroot@#1/#2/#3\opt@stop{%
  \def\option@root{#1}%
  \ifx\option@root\@empty
    \def\option@root{#2}%
  \fi
}

% \option@splitkey{key}: \option@path and \option@name
% \option@splitkey{/foo/bar/baz} -> /foo/bar baz
\newrobustcmd*\option@splitkey[1]{%
  \let\option@path\@empty
  \ifoptionisabsolute{#1}{%
    \def\do##1##2##3{%
      \edef\option@path{##1/}%
      \edef\option@name{##3}%
      \opt@break
    }
    \option@foreachparent{#1}%
  }{\edef\option@name{#1}}%
}


% \option@foreachparent{<path>}  basic routine for iterating over path components
% applies \do to each parent path. 
%   /foo/bar/baz  -> \do{/foo/bar}{}{baz} \do{/foo}{bar/}{baz} \do{}{foo/bar/}{baz} 
\newrobustcmd*\option@foreachparent[1]{%
  \let\opt@donext\do%
  \expandafter\opt@foreachparent@#1/\opt@stop\opt@stop%
  \do{}{\option@subpath}{\option@name}%
}

\newrobustcmd*\opt@break{\def\opt@donext##1##2##3{}}

\def\opt@foreachparent@/#1/#2\opt@stop#3\opt@stop{% #3 is the current root
  \def\opt@temp{#2}%
  \ifx\opt@temp\@empty% final key
    \def\option@name{#1}%
    \def\option@subpath{}%
  \else
    \opt@foreachparent@/#2\opt@stop#3/#1\opt@stop% recurse first
    \opt@donext{#3/#1}{\option@subpath}{\option@name}%
    \edef\option@subpath{#1/\option@subpath}%
  \fi
}


% --------------------------------------------------------
% Default handlers
% --------------------------------------------------------

\newrobustcmd*\optionerror[2][\optionpath]{\PackageError{options}{option "#1": #2}{}}
\newrobustcmd*\optionexpecterror[2][\optionpath]{\optionerror[#1]{unexpected "\optionvalue" (expecting #2)}}
\newrobustcmd*\optiontoomanyerror[2][\optionpath]{\optionerror[#1]{too many arguments (expecting #2)}}

% \optionaddsearch{<path>}{<search paths>}
% add new search paths to a path.
% for efficiency we expand out the search code inline instead of iterating
\newrobustcmd*\optionaddsearch[2]{%
  \def\do##1{%
    \edef\opt@temp{%
      \noexpand\ifx\noexpand\opt@trykey\noexpand\relax
        \noexpand\opt@searchforabskey{##1/\noexpand\option@searchkey}%
      \noexpand\fi
    }%
    \expandnext{\option@append{#1/.searchalso}}{\opt@temp}%
  }
  \expandnext\docsvlist{#2}%
}


% --------------------------------------------------------
% Basic option setting
% --------------------------------------------------------

\newrobustcmd*\edefoption[2]{\protected@edef#2{\option{#1}}}%

\newrobustcmd*\option@setkey[2]{\csdef{optk@#1}{#2}}
\newrobustcmd*\option@letkey[2]{\cslet{optk@#1}#2}

\newrobustcmd*\option@def[1]{\csdef{optk@#1}}

\newrobustcmd*\option@esetkey[2]{\expandnext{\option@setkey{#1}}{#2}}
\newrobustcmd*\option@xsetkey[2]{\protected@edef\opt@temp{#2}\option@letkey{#1}\opt@temp}
\newrobustcmd*\option@expand[1]{\option@xsetkey{\option{#1}}}

\newrobustcmd*\option@append[2]{\csappto{optk@#1}{#2}}
\newrobustcmd*\option@eappend[2]{\ecsappto{optk@#1}{#2}}
\newrobustcmd*\option@prepend[2]{\cspreto{optk@#1}{#2}}

\newrobustcmd*\ifoptiondefined[1]{\ifcsdef{optk@#1}}
\newrobustcmd*\ifoptionvoid[1]{\ifcsvoid{optk@#1}}
\newrobustcmd*\ifoptioncmd[1]{\ifcsparam{optk@#1}}

\newrobustcmd*\ifoptionequal[2]{%
  \letoption{#1}\opt@temp
  \eifstrequal{\opt@temp}{#2}%
}

\newrobustcmd*\ifoptionblank[2]{%
  \letoption{#1}\opt@temp
  \eifblank{\opt@temp}{#2}%
}


% --------------------------------------------------------
% Comma seperated values
% --------------------------------------------------------

\newcommand\headof[1]{\opt@headof#1,\opt@stop}%
\def\opt@headof#1,#2\opt@stop{#1}%

\providerobustcmd*\ifanyof[2]{%
  \let\opt@do@next\@secondoftwo
  \edef\opt@temp{#1}%
  \def\do##1{\eifstrequal{\opt@temp}{##1}{\let\opt@do@next\@firstoftwo\listbreak}{}}%
  \expandnext\docsvlist{#2}%
  \opt@do@next
}

\newrobustcmd*\ifoptionanyof[2]{\ifanyof{\valueof{#1}}{#2}}

\newcount\opt@idx
\providerobustcmd*\findidx[3]{%
  \opt@idx=0\relax
  \def#3{-1}%
  \edef\opt@temp{#1}%
  \def\do##1{\eifstrequal{\opt@temp}{##1}{\edef#3{\the\opt@idx}\listbreak}{\advance\opt@idx 1\relax}}%
  \expandnext\docsvlist{#2}%
}

% return the first letter of the argument or ' ' (space) if the input was empty. Does not expand the argument.
\providecommand*\firstletterof[1]{\eifblank{#1}{ }{\expandafter\opt@firstletterof@#1\opt@stop}}
\def\opt@firstletterof@#1#2\opt@stop{#1}

% --------------------------------------------------------
% Lists
% --------------------------------------------------------

\newrobustcmd*\option@setnil[1]{\option@setkey{#1}{}}
\newrobustcmd*\option@push[2]{\listcsadd{optk@#1}{#2}}
\newrobustcmd*\option@epush[2]{\listcseadd{optk@#1}{#2}}%
\newrobustcmd\optionlistdo[2]{\def\opt@@do##1{#2}\forlistcsloop{\opt@@do}{optk@#1}}

\newrobustcmd*\option@setlist[2]{\option@setnil{#1}\option@concat{#1}{#2}}
\newrobustcmd*\option@concat[2]{%
  \def\do##1{\option@push{#1}{##1}}%
  \expandnext\docsvlist{#2}%
}
\newcommand*\letoptionlist[2]{%
  \def#2{}%
  \optionlistdo{#1}{%
    \ifdefempty#2%
      {\def#2{##1}}%
      {\appto#2{,##1}}%
  }%
}
\newcommand*\optionlist[1]{%
  \optionlistdo{#1}{,##1}%
}


\newrobustcmd*\ifoptioncontains[2]{\xifinlistcs{#2}{optk@#1}}

\let\ifoptionnil\ifoptionvoid

\newrobustcmd*\option@pushifnew[2]{\ifoptioncontains{#1}{#2}{}{\option@push{#1}{#2}}}


% --------------------------------------------------------
% Assign
% --------------------------------------------------------

\newrobustcmd*\option@eassign[2]{%
  \protected@edef\opt@temp{#2}%
  \expandnext{\option@assign{#1}}{\opt@temp}%
}%
\newrobustcmd*\option@assign[2]{%
  \protected@edef\optionpath{#1}%
  \def\optionvalue{#2}%
  \option{\optionpath/@code}%
}%
\newrobustcmd*\option@assigndefault[1]{%
  \protected@edef\optionpath{#1}%
  \let\optionvalue\optionnovalue%
  \option{\optionpath/@code}%
}%


% --------------------------------------------------------
% Ensure arg/noarg/free/defined
% --------------------------------------------------------

\newrobustcmd*\option@ensurearg{%
  \ifx\optionvalue\optionnovalue
    \ifoptiondefined{\optionpath/@def}%
      {\letoption{\optionpath/@def}\optionvalue}%
      {\optionerror{requires a value}}%
  \fi
}%   
\newrobustcmd*\option@ensurenoarg{%
  \ifx\optionvalue\optionnovalue\else
    \optionerror{cannot take an argument (=\optionvalue)}%
  \fi
}%   
\newrobustcmd*\option@settoarg{\option@letkey{\optionpath}{\optionvalue}}%   

\newrobustcmd*\option@ensurefree[1]{%
  \ifoptiondefined{#1}{%
    \optionerror[#1]{already defined}%
  }{}%
}%   
\newrobustcmd*\option@ensuredefined[1]{%
  \ifoptiondefined{#1}{}{%
    \optionerror[#1]{unknown option}%
  }%
}%


% --------------------------------------------------------
% Parse default arguments []
% --------------------------------------------------------

\def\opt@parsedefaultnoarg#1{\@ifnextchar[{\opt@errordefault{#1}}{}}
\def\opt@parsedefaultarg#1{\@ifnextchar[{\opt@setdefault{#1}}{}}
\def\opt@setdefault#1[#2]{\option@setkey{#1/@def}{#2}}
\def\opt@errordefault#1[#2]{\optionerror[#1]{a starred option definition does not take a default argument "[#2]"}}

% --------------------------------------------------------
% Record metadata
% --------------------------------------------------------

\newrobustcmd*\option@addkeyinfo[1]{%
  \def\do##1##2##3{%
    \ifoptiondefined{##1/.names}{}{%
      \option@setnil{##1/.names}\option@setnil{##1/.paths}%
    }%
    \eifblank{##2}%
      {\expandnext{\option@pushifnew{##1/.names}}{##3}%
       %\typeout{path "##1/.names": add "##3": \option{##1/.names}}%      
      }%
      {\option@splitroot{##2}%
       \expandnext{\option@pushifnew{##1/.paths}}{\option@root}%
       %\typeout{path "##1/.paths": add "\option@root"; \option{##1/.paths}}%
      }%
  }
  \option@foreachparent{#1}%
}

% --------------------------------------------------------
% Basic definitions of options
% --------------------------------------------------------
\def\opt@patch@check{}

\newrobustcmd*\optionnewcode{\@ifstar{\optionnewcode@{noarg}}{\optionnewcode@{arg}}}
\newrobustcmd*\optionnewcode@[3]{%*[]
  %\typeout{define cmd: #2}%  
  \option@ensurefree{#2}%
  \option@splitkey{#2}% sets option@path, and option@name
  \eifblank{\option@path}{%
    \optionerror[#2]{no valid option name specified. Option definitions must start with a forward slash (i.e. "/path/<name>")}%
  }{}%
  \option@addkeyinfo{#2}%
  \csdef{optk@#2/@code}{%
    %\typeout{invoke #2 (\optionpath)= \meaning\optionvalue}%
    \csuse{option@ensure#1}%
    \opt@patch@check% hook to patch in extra checking code
    #3%
  }%
  \csletcs{optk@#2}{optk@#2/@code}% point at first to the cmd
  \csuse{opt@parsedefault#1}{#2}% parse potential default argument
}

\newrobustcmd*\optionnewcodevalue[4]{%[]
  \optionnewcode{#1}{#2}%
  \option@setkey{#1}{#3}%
  \option@setkey{#1/@ini}{#4}%
  \option@assign{#1}{#4}% this invokes the cmd the first time  
  \opt@parsedefaultarg{#1}% parse potential default argument
}

\newrobustcmd*\optionnewcheckedvalue[3]{%[]
  \optionnewcode{#1}{%
    #2%
    \option@letkey{#1}{\optionvalue}%
  }%
  \option@setkey{#1/@ini}{#3}%
  \option@assign{#1}{#3}% this invokes the cmd the first time  and assigns the initial value
  \opt@parsedefaultarg{#1}% set default value?
}

\newrobustcmd*\optionnewvalue[2]{%[]
  \optionnewcheckedvalue{#1}{}{#2}%
}

% --------------------------------------------------------
% command actions take arguments
% --------------------------------------------------------

% new command with just the option value as an argument
\newrobustcmd*\optionnewcmd[2]{\optionnewcmdn{1}{#1}{#2}}

% provide n arguments: 0 and 1 argument is always checked for too few/too many arguments
% 2+ only checks for too many arguments and defaults with too few to empty arguments
\newrobustcmd*\optionnewcmdn[3]{%
  \ifnum#1<1\relax
    \optionnewcode*{#2}{#3}%
  \else\ifnum#1=1\relax
    \option@def{#2/@cmd1}##1{#3}%
    \optionnewcode{#2}{\expandnext{\option{#2/@cmd1}}{\optionvalue}}%
  \else
    \ifcase#1\relax\or\relax
    \or\option@def{#2/@cmd2}##1##2##3{\ifblank{##3}{#3}{\optiontoomanyerror[#2]{#1}}}%
    \or\option@def{#2/@cmd3}##1##2##3##4{\ifblank{##4}{#3}{\optiontoomanyerror[#2]{#1}}}%
    \or\option@def{#2/@cmd4}##1##2##3##4##5{\ifblank{##5}{#3}{\optiontoomanyerror[#2]{#1}}}%
    \else
      \option@error[#2]{expecting at most 4 arguments but got "#1"}%
    \fi
    \optionnewcode{#2}{\expandnextx{\option{#2/@cmd#1}}{\optionvalue}{}{}{}{}{}}%
  \fi
  \fi
  \opt@parsedefaultarg{#2}%
}

% provide any command pattern
\newrobustcmd*\optionnewcmdx[4]{%
  \option@def{#1/@cmdx}#2\opt@stop{#4}%
  \optionnewcode{#1}{\expandnextx{\option{#1/@cmdx}}{\optionvalue#3\opt@stop}}%
}


% define cmd handler; such handler code takes the expanded option@handlerkey and optionvalue as arguments 
% and do not chain with other handlers
\newrobustcmd*\optionnewhandlercmd[2]{%
  \option@ensurefree{/handlers/#1}%
  \option@def{/handlers/#1/@cmd2}##1##2{#2}%
  \optionnewcode{/handlers/#1}{\expandnext{\expandnext{\option{/handlers/#1/@cmd2}}{\option@handlerkey}}{\optionvalue}\option@chainempty}%
}



% --------------------------------------------------------
% Add pre/post processing to an option
% --------------------------------------------------------

\newrobustcmd*\optionaddcheck[2]{%
  \option@ensuredefined{#1}%
  \expandafter\patchcmd\expandafter{\csname optk@#1/@code\endcsname}{\opt@patch@check}{#2\opt@patch@check}{}{\optionerror[#1]{unable to prepend extra option check}}%
}

% make an option that always expands its argument
\newrobustcmd*\optionaddexpands[1]{%
  \optionaddcheck{#1}{\protected@edef\optionvalue{\optionvalue}}%
}

% add a custom show function for this option value
\newrobustcmd*\optionaddshow[2]{%
  \def\opt@temp##1{#2}%
  \option@letkey{/handlers/show/#1}\opt@temp%
}

% add a default option
\newrobustcmd*\optionadddefault[2]{%
  \opt@setdefault{#1}[#2]%
}



% --------------------------------------------------------
% Default unknown handler
% --------------------------------------------------------

% Default unknown key handler.
\optionnewcode{/.unknown}{%
  \let\opt@trykey\relax
  \eifblank{\option@unknownpath}{\def\option@unknownpath{?}}{}%
  \ifoptionisabsolute{\option@unknownpath}%
    {\optionerror[\option@unknownpath]{unknown option}}%
    {\optionerror[\option@unknownpath]{unknown option under "\opt@defaultpath"}}%
}[]


% --------------------------------------------------------
% Helper to parse initial values that contain a default too
% e.g. [5pt]6pt  is default of 5pt, and initial of 6pt
% --------------------------------------------------------

\newrobustcmd*\option@withdefault[2]{%
  \option@parsedefault{#2}%
  \ifx\option@default\optionnovalue
    #1{#2}%
  \else
    \edef\option@initial{\the\opt@temptoks}%
    \expandnext{\expandnext{\option@withdefault@{#1}}{\option@initial}}{\option@default}%
  \fi
}
\newrobustcmd*\option@withdefault@[3]{#1{#2}[#3]}
\newrobustcmd*\option@parsedefault[1]{\expandafter\option@parsedefault@#1\opt@stop}
\def\option@parsedefault@{\@ifnextchar [{\option@parsedefault@opt}{\option@parsedefault@ini}}
\def\option@parsedefault@opt[#1]#2\opt@stop{\def\option@default{#1}\opt@temptoks{#2}}
\def\option@parsedefault@ini#1\opt@stop{\let\option@default\optionnovalue}


% --------------------------------------------------------
% Derived option definitions
% --------------------------------------------------------

\newrobustcmd*\option@new@type[2]{\option@ensurefree{#1}\option@setkey{#1/@type}{#2}}
\newrobustcmd*\option@settype[2]{\option@setkey{#1/@type}{#2}}
\newrobustcmd*\ifoptiontype[2]{\edefoption{#1/@type}\opt@type\eifstrequal{\opt@type}{#2}}

\newrobustcmd*\optionnewstyle{\@ifstar{\optionnewstyle@{\optionnewcode*}}{\optionnewstyle@{\optionnewcmd}}}
\newrobustcmd*\optionnewstyle@[3]{#1{#2}{\optionsalso{#3}}\option@settype{#2}{style}}

\newrobustcmd*\optionnewfamily[2]{%
  \optionnewcode*{#1}{\edef\opt@defaultpath{\optionpath}}%
  \optionaddsearch{#1}{#2}%
}

\newrobustcmd*\optionnewif[2]{%
  \ifcsdef{if#2}{}{\optionerror[#1]{no `if` with name "#2" is defined}}%
  \option@new@type{#1}{if}%
  \optionnewcode{#1}{%
    \ifcsdef{#2\optionvalue}%
      {\csuse{#2\optionvalue}}%
      {\optionexpecterror{a boolean value}}%
  }[true]%
  \option@setkey{#1}{#2}% return the name of the if
}

\newrobustcmd*\optionnewdef[2]{%
  \ifdef{#2}{}{\optionerror[#1]{no definition "\detokenize{#2}" is found}}%
  \option@new@type{#1}{def}%
  \optionnewcode{#1}{\expandafter\def\expandafter#2\expandafter{\optionvalue}}%
  \option@setkey{#1}{#2}% read points to definition
  \opt@parsedefaultarg{#1}% parse default arg?
}

\newrobustcmd*\optionnewedef[2]{%
  \ifdef{#2}{}{\optionerror[#1]{no definition "\detokenize{#2}" is found}}%
  \option@new@type{#1}{edef}%
  \optionnewcode{#1}{\protected@edef#2{\optionvalue}}%
  \option@setkey{#1}{#2}% read points to definition
  \opt@parsedefaultarg{#1}% parse default arg?
}

\newrobustcmd*\optionnewcounter[2]{%
  \ifltxcounter{#2}{}{\optionerror[#1]{no counter with name "#2" is defined}}%
  \option@new@type{#1}{counter}%
  \optionnewcode{#1}{\setcounter{#2}{\optionvalue}}%
  \option@setkey{#1}{#2}% read returns the plain name of the counter 
  \opt@parsedefaultarg{#1}% parse default arg?
}
\optionaddshow{counter}{\option@showvalue{\option{#1}} (=\option@font@value{\arabic{\option{#1}}})}


\newrobustcmd*\optionnewtoggle[2]{%
  \option@new@type{#1}{toggle}%
  \newtoggle{#1}%
  \optionnewcodevalue{#1}{%
    \ifcsdef{toggle\optionvalue}%
      {\csuse{toggle\optionvalue}{#1}}%
      {\optionexpecterror{a boolean value}}%
  }%
  {#1}% point to the name of the toggle
  {#2}% initial assignment
  [true]% always just true as default value
}

\newrobustcmd*\optionnewchoice[2]{%  
  \option@new@type{#1}{choice}%
  \option@setkey{#1/@ord}{0}% 
  \option@xsetkey{#1/@tag}{\firstletterof{#2}}%
  \optionnewcheckedvalue{#1}{%
    \edef\optionvalue{\optionvalue}%
    %\typeout{option choice: #1=\meaning\optionvalue}%
    \expandnext\findidx{\optionvalue}{#2}\option@choiceidx%
    \ifnum\option@choiceidx<0
      \optionexpecterror{one of "#2"}%
    \else
      \option@esetkey{#1/@ord}{\option@choiceidx}%
      \option@xsetkey{#1/@tag}{\firstletterof{\optionvalue}}
    \fi
  }%
  {\headof{#2}}% initial value
}
\optionaddshow{choice}{%
  \option@showvalue{\option{#1}} 
  (\option@font@name{@ord}=\option{#1/@ord},%
   \option@font@name{@tag}=\option@font@value{\option{#1/@tag}})%
}%


\newrobustcmd*\optionnewlength[2]{%
  \option@new@type{#1}{length}%
  \csnewlength{#1}%
  \optionnewcodevalue{#1}{\cssetlength{#1}{\dimexpr\optionvalue\relax}}%
  {\csuse{#1}}% read value
  {#2}% initial value
}
\optionaddshow{length}{\option@showvalue{\the\option{#1}}}%

\newrobustcmd*\optionnewdim[2]{%
  \option@new@type{#1}{dim}%
  \optionnewcodevalue{#1}{\option@esetkey{#1/@dimexpr}{\optionvalue}}% keep the unevaluated dim expr
  {\dimexpr\option{#1/@dimexpr}\relax}% read as dimexpr
  {#2}% initial
}
\optionaddshow{dim}{\option@showvalue{\the\option{#1}}\ (=\optionshowliteral{#1/@dimexpr})}

\newrobustcmd*\optionnewnum[2]{%[]
  \option@new@type{#1}{num}%
  \optionnewcodevalue{#1}{\option@esetkey{#1}{\the\numexpr \optionvalue\relax}}%
  {0}% start as 0
  {#2}% initial value
}

\newrobustcmd*\optionnewlist[2]{%
  \option@new@type{#1}{list}%
  \optionnewcodevalue{#1}{\option@setlist{#1}{\optionvalue}}%
  {}% initial read
  {#2}% initial value
}
\optionaddshow{list}{\letoptionlist{#1}\opt@list\typeout{gotten}\option@showvalue{\opt@list}}%



% --------------------------------------------------------
% Initial handlers
% --------------------------------------------------------

\optionnewif{/options/ignoreunknown}{opt@ignoreunknown}
\optionnewif{/options/allowsearch}{opt@allowsearch}
\optionnewlist{/options/remaining}{}

% general operations on keys
\optionnewcode*{/handlers/.cd}{\edef\opt@defaultpath{\option@handlerkey}\option@chainempty}
\optionnewcode*{/handlers/.expands}{\expandnext\optionaddexpands{\option@handlerkey}\option@chainempty}
\optionnewcode*{/handlers/.show}{\expandnext\optionshow{\option@handlerkey}\option@chainempty}
\optionnewcode{/options/exec}{\optionvalue}%

% transformations on the argument
\optionnewcode{/handlers/.expand once}{\defexpandonce\optionvalue\option@chain}
\optionnewcode{/handlers/.expand twice}{\defexpandtwice\optionvalue\option@chain}
\optionnewcode{/handlers/.expanded}{\protected@edef\optionvalue{\optionvalue}\option@chain}

\optionnewcode{/handlers/.push}{\expandnext{\option@push{\option@handlerkey}}{\optionvalue}\option@chainonly}
\optionnewcode{/handlers/.concat}{\expandnext{\option@concat{\option@handlerkey}}{\optionvalue}\option@chainonly}

% tranform numbers and counters
\optionnewcode{/handlers/.inc}{%
  \ifx\optionvalue\optionnovalue\def\optionvalue{1}\fi
  \ifoptiontype{\option@handlerkey}{counter}% check if this is a counter or a number
    {\addtocounter{\option{\option@handlerkey}}{\optionvalue}}%
    {\option@eassign{\option@handlerkey}{\option{\option@handlerkey} + \optionvalue}}%
  \option@chainonly%
}[1]

\optionnewcode*{/handlers/.step}{%
  \ifoptiontype{\option@handlerkey}{counter}% check if this is a counter 
    {\stepcounter{\option{\option@handlerkey}}}%
    {\optionerror[\option@handlerkey]{cannot "step" a non-counter}}%
  \option@chainempty%
}
\optionnewcode*{/handlers/.refstep}{%
  \ifoptiontype{\option@handlerkey}{counter}% check if this is a counter 
    {\refstepcounter{\option{\option@handlerkey}}}%
    {\optionerror[\option@handlerkey]{cannot "refstep" a non-counter}}%
  \option@chainempty%
}

% new types
\optionnewhandlercmd{.new cmd}{\option@withdefault{\optionnewcmd{#1}}{#2}}
\optionnewhandlercmd{.new cmd*}{\optionnewcode*{#1}{#2}}
\optionnewhandlercmd{.new style}{\optionnewcmd{#1}{\optionsalso{#2}}}
\optionnewhandlercmd{.new style*}{\optionnewcode*{#1}{\optionsalso{#2}}}
\optionnewhandlercmd{.new value}{\option@withdefault{\optionnewvalue{#1}}{#2}}
\optionnewhandlercmd{.new length}{\option@withdefault{\optionnewlength{#1}}{#2}}
\optionnewhandlercmd{.new dim}{\option@withdefault{\optionnewdim{#1}}{#2}}
\optionnewhandlercmd{.new num}{\option@withdefault{\optionnewnum{#1}}{#2}}
\optionnewhandlercmd{.new choice}{\option@withdefault{\optionnewchoice{#1}}{#2}}
\optionnewhandlercmd{.new toggle}{\optionnewtoggle{#1}{#2}}
\optionnewhandlercmd{.new list}{\option@withdefault{\optionnewlist{#1}}{#2}}
\optionnewhandlercmd{.new family}{\optionnewfamily{#1}{#2}}[]

% hook into existing definitions
\optionnewhandlercmd{.is if}{\optionnewif{#1}{#2}}
\optionnewhandlercmd{.is counter}{\optionnewcounter{#1}{#2}}
\optionnewhandlercmd{.is def}{\option@withdefault{\optionnewdef{#1}}{#2}}
\optionnewhandlercmd{.is edef}{\option@withdefault{\optionnewedef{#1}}{#2}}


% compatibility with pgfkeys
\optionnewstyle{/handlers/.code}{\option@handlerkey/.cmd={#1}}
\optionnewstyle{/handlers/.style}{\option@handlerkey/.new style={#1}}
\optionnewstyle*{/handlers/.is family}{\option@handlerkey/.new family}
\optionnewhandlercmd{.search also}{\optionaddsearch{#1}{#2}}
\optionnewhandlercmd{.default}{\optionadddefault{#1}{#2}}

% multi argument commands
\optionnewhandlercmd{.new cmd 0}{\optionnewcode*{#1}{#2}}
\optionnewhandlercmd{.new cmd 1}{\option@withdefault{\optionnewcmd{#1}}{#2}}
\optionnewhandlercmd{.new cmd 2}{\option@withdefault{\optionnewcmdn{2}{#1}}{#2}}
\optionnewhandlercmd{.new cmd 3}{\option@withdefault{\optionnewcmdn{3}{#1}}{#2}}
\optionnewhandlercmd{.new cmd 4}{\option@withdefault{\optionnewcmdn{4}{#1}}{#2}}
\optionnewcmdn{3}{/handlers/.new cmdx}{\option@withdefault{\expandnext\optionnewcmdx{\option@handlerkey}{#1}{#2}}{#3}\option@chainempty}

% tuples and triples take exactly 2/3 arguments
\newrobustcmd*\optionnewtuple[2]{%
  \optionnewcmdx{#1}{##1,##2,##3}{,,}%
    {\ifstrequal{##3}{,}{#2}{\optionerror{expecting a 2 argument tuple \{_,_\}, but got "\optionvalue"}}}%
}
\newrobustcmd*\optionnewtriple[2]{%
  \optionnewcmdx{#1}{##1,##2,##3,##4}{,,,}%
    {\ifstrequal{##4}{,,}{#2}{\optionerror{expecting a 3 argument triple \{_,_,_\}, but got "\optionvalue"}}}%
}
\optionnewhandlercmd{.new cmd tuple}{\option@withdefault{\optionnewtuple{#1}}{#2}}
\optionnewhandlercmd{.new cmd triple}{\option@withdefault{\optionnewtriple{#1}}{#2}}




% --------------------------------------------------------
% Show definitions
% --------------------------------------------------------
\optionnewtoggle{/options/showbuiltin}{false}

\newrobustcmd*\optionshowall[1][false]{\csuse{toggle#1}{/options/showbuiltin}\optionshowpath{}}

\newrobustcmd*\option@font@name[1]{\textsf{#1}}
\newrobustcmd*\option@font@path[1]{\textsf{#1}}
\newrobustcmd*\option@font@value[1]{\textsf{#1}}
\newrobustcmd*\option@font@special[1]{\textit{#1}}

\newrobustcmd*\option@showvalue[1]{$\langle$\option@font@value{#1}$\rangle$}

\newrobustcmd*\optionshowpath[2][]{\option@showpath{#1#2}{#2}}
\newrobustcmd*\option@showpath[2]{%
  \noindent\option@font@path{#2/}%
  \option@showitems{/.names}{\option@showname}{#1}%
  \option@showitems{/.paths}{\option@showpath}{#1}%
}

\newrobustcmd*\option@showitems[3]{%
  \ifoptionvoid{#3#1}{}{%
    \begin{opt@marginlr}{1em}{0em}
     \optionlistdo{#3#1}{%
       \iftoggle{/options/showbuiltin}{}%
         {\ifanyof{#3/##1}{/handlers,/options}{\@gobble}%
          {\if\firstletterof{##1}.\relax\expandafter\@gobble\fi}}%
       {%
         \noindent\hspace*{-0.5em}#2{#3/##1}{##1}%
         \par%
       }%
     }%
    \end{opt@marginlr}%
  }%
}

\newrobustcmd*\option@showname[2]{%
  \option@font@name{#2}%
  =\optionshow{#1}%
  \ifoptiondefined{#1/@ini}{%
    , initial=\optionshowliteral{#1/@ini}%
  }{}%
  \ifoptiondefined{#1/@def}{%
    , default=\optionshowliteral{#1/@def}%
  }{}%
}

\newrobustcmd*\optionshowliteral[1]{\letoption{#1}\opt@temp\option@showvalue{\texttt{\expandnext\detokenize{\opt@temp}}}}

\newrobustcmd*\ifoptioniscode[1]{%
  \letoption{#1}\opt@temp
  \letoption{#1/@code}\opt@code
  \ifx\opt@temp\opt@code\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi
}

\newrobustcmd*\optionshow[1]{%
  \ifoptiondefined{#1/@type}%
    {\ifoptiondefined{/handlers/show/\option{#1/@type}}{\@firstoftwo}{\@secondoftwo}}%
    {\@secondoftwo}%
  {\option{/handlers/show/\option{#1/@type}}{#1}}%
  {\ifoptiondefined{#1}
    {\ifoptioniscode{#1}%
      {\option@font@special{cmd}}%
      {\option@showvalue{\option{#1}}}}%
    {\option@font@special{undefined}}%
  }%
}


\newenvironment{opt@marginlr}[2]{%
  \topsep\z@
  \partopsep\z@
  \trivlist
  \rightmargin=\dimexpr#2\relax%
  \leftmargin=\dimexpr#1\relax%  
  \advance\linewidth -\rightmargin
  \advance\linewidth -\leftmargin
  \advance\@totalleftmargin \leftmargin
  \parshape \@ne \@totalleftmargin \linewidth
  \item[]%
}%
{\endtrivlist}

% restore cat codes
\opt@restore@catcodes
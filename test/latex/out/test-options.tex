\documentclass{book}
% generated by Madoko, version 0.9.5-beta
%mdk-data-line={1}

\usepackage{etoolbox}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{enumitem}

\makeatletter
% --------------------------------------------------------
% 
% --------------------------------------------------------

% - newoptioncmd{/fam/key}[default]{cmd}
%
% - newoptionfamily: {fam}{delegates}
% - newoptionstyle:  code on new keys
% - newoptionvalue:  {/fam/key}[default][initial]
% - newoptiontoggle: {/fam/key}[initial]
% - newoptiondimen:  {/fam/key}[initial]
% - newoptionchoice: {/fam/key}{choices}
% - newoptioncolor:  {/fam/key}[initial]
%
% - optionsreset{names}         : set back to original values
% - optionsset{options}\<name>  : process options, and set \<name> to the processed options
% - optionssetalso{options}     : used inside optionsset
%
% - option{/fam/key}: return the value 
% - letoption{/fam/key}\<name>
% - ifoptionequals
% - ifoptionblank

\newif\ifopt@ignoreunknown
\newif\ifopt@nosearch

\newrobustcmd*\optionset[1]{%
  \def\opt@defaultpath{/}%
  \opt@nosearchfalse%
  \opt@ignoreunknownfalse%
  \optionsetalso{#1}%
}
\newrobustcmd*\optionsetalso[1]{\opt@do#1,\relax,}


% The main parsing of options
% This code is quite expanded to make it as efficient as possible.
% It is a slight modification of the original code by David Carlisle in the 
% standard latex "keyval" package.
\def\opt@do#1,{%
 \ifx\relax#1\empty\else
  \opt@split#1==\relax
  \expandafter\opt@do\fi}


\def\opt@split#1=#2=#3\relax{%
  \opt@@sp@def\option@rawkey{#1}%
  \ifx\option@rawkey\@empty\else
    % get value
    \ifx\@empty#3\@empty
      \let\option@value\opt@default
    \else
      \opt@@sp@def\option@value{#2}%
    \fi
    % try key directly
    \option@ifisabsolute{\option@rawkey}%
      \let\option@key\option@rawkey%
    \else
      \edef\option@key{\opt@defaultpath\option@rawkey}% use default path
    \fi
    \letoption\option@key\opt@trykey
    \ifx\opt@trykey\relax
      % not directly found..
      \option@gethandler\option@key% defines option@handlerkey & option@handler
      \ifx\option@handler\@empty
        % search key
        \ifopt@nosearch\else
          \opt@searchalso{\option@key}%
        \fi
      \else
        % handler
        \letoption{/handlers/\option@handler}\opt@trykey
        \ifx\opt@trykey\relax\else
          \edef\option@key{/handlers/\option@handler}% will get \option@handlerkey
        \fi
      \fi
      \ifx\opt@trykey\relax
        % still not found: invoke unknown handler
        \opt@unknown{\option@key}%        
      \fi
    \fi
    % now \option@key and \option@value are defined; invoke the /.cmd
    \typeout{call \option@key/.cmd }%
    \csname optk@\option@key/.cmd\endcsname{\option@value}%
  \fi
}

% magic option parsing ;-) Basically unchanged from original definition in the keyval package 
\def\option@rawkey#1{%
\def\opt@@sp@def##1##2{\opt@@sp@b##2\@nil\@nil#1\@nil\relax##1}}
\option@rawkey{ }
\def\opt@@sp@b#1#2 \@nil{\opt@@sp@c#1#2}
\def\opt@@sp@c#1\@nil#2\relax#3{\def#3{#1}}


% search a key
\newrobustcmd*\opt@searchforkey[2]{%
  \option@ifisabsolute{#2}%
    \letoption{#2}\opt@trykey
    \ifx\opt@trykey\relax\else
      \edef\option@key{#2}%
    \fi
  \else  
    \letoption{#1#2}\opt@trykey% use default path
    \ifx\opt@trykey\relax
      \ifopt@nosearch\else
        \opt@searchalso{#1#2}%
      \fi
    \else    
      \edef\option@key{#1#2}% !found
    \fi
  \fi
}

% note: we can nest searches without grouping
% because they all use the same "\do" (option@searchalsodo) and
% all need to break once the inner one breaks (so it is fine if \opt@break redefined \do)
\newrobustcmd*\opt@searchalso[1]{%
  \typeout{searchalso #1}%
  \let\do\opt@searchalsodo
  \option@foreachparent{#1}%
}
\newrobustcmd*\opt@searchalsodo[3]{%
  \opt@onkeyexist{#1/.searchalso}{%
    \edef\option@searchkey{#2#3}% subpath
    \csname optk@#1/.searchalso\endcsname%
    \ifx\opt@trykey\relax\else\opt@break\fi% on found: break
  }%
}

\newrobustcmd*\opt@unknown[1]{%
  \def\do##1##2##3{%
    \opt@onkeyexist{##1/.unknown/.cmd}{%
      \edef\option@unknownkey{#1}% full key
      \edef\option@unknownsubpath{##2##3}% subpath
      \edef\option@key{##1/.unknown}%
      \opt@break%
    }%
  }
  \option@foreachparent{#1}%
}

% option@gethandler{key}: split off the part after the ".", sets option@handlerkey and option@handler
\def\option@gethandler#1{\expandafter\option@gethandler@#1../relax}
\def\option@gethandler@#1.#2.#3/relax{%
  \def\option@handlerkey{#1}%
  \def\option@handler{#2}%
  \ifx\option@handler\@empty\else\def\option@handler{.#2}\fi%
}

% option@isabsolute{key}: check if key starts with /
\def\option@ifisabsolute#1{\expandafter\option@ifisabsolute@#1/\relax}
\def\option@ifisabsolute@#1/#2\relax{\def\opt@temp{#1}\ifx\opt@temp\@empty}

% the default value
\def\opt@default{}

% check if a key exists; sets \option@key and \opt@trykey
\def\opt@ifnokey#1{%
  \expandafter\let\expandafter\opt@trykey\csname optk@#1\endcsname
  \ifx\opt@trykey\relax
}
\def\opt@onkeyexist#1#2{%
  \expandafter\let\expandafter\opt@temp\csname optk@#1\endcsname
  \ifx\opt@temp\relax\else#2\fi
}


% option@foreachparent{<path>}
% applies \do to each parent path. 
%   /foo/bar/baz  -> \do{/foo/bar}{}{baz} \do{/foo}{bar/}{baz} \do{}{foo/bar/}{baz} 

\newrobustcmd*\option@foreachparent[1]{%
  \let\opt@donext\do%
  \expandafter\opt@foreachparent@#1/\relax\relax%
  \do{}{\option@subpath}{\option@name}%
}

\newrobustcmd*\opt@break{\def\opt@donext##1##2##3{}}


\def\opt@foreachparent@/#1/#2\relax#3\relax{% #3 is the current root
  \def\opt@temp{#2}%
  \ifx\opt@temp\@empty% final key
    \def\option@name{#1}%
    \def\option@subpath{}%
  \else
    \opt@foreachparent@/#2\relax#3/#1\relax% recurse first
    \opt@donext{#3/#1}{\option@subpath}{\option@name}%
    \edef\option@subpath{#1/\option@subpath}%
  \fi
}



% \option@splitkey{key}: \option@path and \option@name
% optione@splitkey{/foo/bar} -> /foo bar
%
\newrobustcmd*\option@splitkey[1]{%
  \let\option@path\@empty
  \option@ifisabsolute{#1}%
    \def\do##1##2##3{%
      \edef\option@path{##1/}%
      \edef\option@name{##3}%
      \opt@break
    }
    \option@foreachparent{#1}%
  \else
    \edef\option@name{#1}%
  \fi
}

% \option@splitroot{path}: split off the first directory of a path into \option@root
% option@splitroot{/foo/bar} -> foo
% option@splitroot{foo/bar}  -> foo
\newrobustcmd*\option@splitroot[1]{\expandafter\option@splitroot@#1//\relax}
\def\option@splitroot@#1/#2/#3\relax{%
  \def\option@root{#2}%
  \ifx\option@root\@empty
    \def\option@root{#1}%
  \fi
}

  

% --------------------------------------------------------
% Extensions to etoolbox
% --------------------------------------------------------


\providerobustcmd*\@swaparg[2]{#2{#1}}
\providerobustcmd*\expandnext[2]{\expandafter\@swaparg\expandafter{#2}{#1}}

% expand an argument and test for string equality
%
% \eifstrequal{<unexpanded s>}{<string>}{<equalcode>}{<unequalcode>}
\providecommand\eifstrequal[1]{%
  \expandnext\ifstrequal{#1}%
}

\providecommand\eifblank[1]{%
  \expandnext\ifblank{#1}%
}

\providecommand\ontoggle[2]{%
  \iftoggle{#1}{#2}{}%
}

\providecommand\providelength[1]{% 
  \ifdef{#1}{}{\newlength#1}%
}

\providecommand\csnewlength[1]{%
  \expandafter\newlength\csname #1\endcsname%
}
\providecommand\csprovidelength[1]{%
  \ifcsdef{#1}{}{\expandafter\newlength\csname #1\endcsname}%
}
\providecommand\cssetlength[2]{%
  \expandafter\setlength\csname #1\endcsname{#2}%
}

% --------------------------------------------------------
% Basic option commands
% --------------------------------------------------------

\newcommand\option[1]{\csname optk@#1\endcsname}
\newrobustcmd*\letoption[2]{\expandafter\let\expandafter#2\csname optk@#1\endcsname}
\newrobustcmd*\eletoption[2]{\protected@edef#2{\csname optk@#1\endcsname}}%

\newrobustcmd*\option@setkey[2]{\csdef{optk@#1}{#2}}
\newrobustcmd*\option@letkey[2]{\cslet{optk@#1}#2}

\newrobustcmd*\option@expand[1]{\eletoption{#1}\reserved@a\option@letkey{#1}\reserved@a}
\newrobustcmd*\option@esetkey[2]{\expandnext{\option@setkey{#1}}{#2}}

\newrobustcmd*\option@append[2]{\ifoptiondefined{#1}{\csappto{optk@#1}{#2}}{\option@setkey{#1}{#2}}}
\newrobustcmd*\option@prepend[2]{\ifoptiondefined{#1}{\cspreto{optk@#1}}{\option@setkey{#1}}{#2}}
\newrobustcmd*\option@listadd[2]{\ifoptiondefined{#1}{\listcseadd{optk@#1}{#2}}{\option@esetkey{#1}{#2|}}}
\newrobustcmd*\option@setadd[2]{\xifinlistcs{#2}{optk@#1}{}{\option@listadd{#1}{#2}}}

\newrobustcmd*\ifoptiondefined[1]{\ifcsdef{optk@#1}}
\newrobustcmd*\ifoptionvoid[1]{\ifcsvoid{optk@#1}}

\newrobustcmd*\ifoptionequal[2]{%
  \eletoption{#1}\reserved@a
  \eifstrequal{\reserved@a}{#2}%
}


\newrobustcmd*\optiondo[1]{%
  \letoption{#1}\opt@list
  \expandnext\dolistloop{\opt@list}%
}

% --------------------------------------------------------
% lists
% --------------------------------------------------------

\newcommand*\headof[1]{\opt@headof#1,\relax}%
\def\opt@headof#1,#2\relax{#1}%

\providerobustcmd*\ifanyof[2]{%
  \let\do@next\@secondoftwo
  \def\do##1{\eifstrequal{#1}{##1}{\let\do@next\@firstoftwo\listbreak}{}}%
  \expandnext\docsvlist{#2}%
  \do@next
}
\providerobustcmd*\eifanyof[2]{%
  \expandnext\ifanyof{#1}{#2}%
}
\providerobustcmd*\ifoptionanyof[2]{%
  \eletoption{#1}\reserved@a
  \eifanyof{\reserved@a}{#2}%
}



% --------------------------------------------------------
% Assign
% --------------------------------------------------------

\newrobustcmd*\optioneassign[2]{%
  \protected@edef\reserved@a{#2}%
  \expandnext{\optionassign{#1}}{\reserved@a}%
}%
\newrobustcmd*\optionassign[2]{%
  \protected@edef\option@key{#1}%
  \def\option@value{#2}%
  \option{\option@key/.cmd}{\option@value}%
}%
\newrobustcmd*\optionassigndefault[1]{%
  \protected@edef\option@key{#1}%
  \let\option@value\opt@default%
  \option{\option@key/.cmd}{\option@value}%
}%

% --------------------------------------------------------
% Ensure arg/noarg/free/defined
% --------------------------------------------------------

\newrobustcmd*\option@ensurearg{%
  \ifx\option@value\opt@default
    \ifoptiondefined{\option@key/.default}%
      {\letoption{\option@key/.default}\option@value%
       \typeout{found default: \option@value}}%
      {\optionerror{requires a value}}%
  \fi
}%   
\newrobustcmd*\option@ensurenoarg{%
  \ifx\option@value\opt@default\else
    \optionerror{cannot take an argument (=\option@value)}%
  \fi
}%   
\newrobustcmd*\option@settoarg{%
  \option@letkey{\option@key}{\option@value}%
}%   

\newrobustcmd*\option@ensurefree[1]{%
  \ifoptiondefined{#1}{%
    \optionerror[#1]{already defined}%
  }{}%
}%   
\newrobustcmd*\option@ensuredefined[1]{%
  \ifoptiondefined{#1}{}{%
    \optionerror[#1]{unknown option}%
  }%
}%



% --------------------------------------------------------
% Parse default arguments []
% --------------------------------------------------------

\def\opt@parsedefaultnoarg#1{\@ifnextchar[{\opt@errordefault{#1}}{}}
\def\opt@parsedefaultarg#1{\@ifnextchar[{\opt@setdefault{#1}}{}}
\def\opt@setdefault#1[#2]{\option@setkey{#1/.default}{#2}}
\def\opt@errordefault#1[#2]{%
  \optionerror[#1]{a starred option definition does not take a default argument "[#2]"}%
}

% --------------------------------------------------------
% Initial values
% --------------------------------------------------------

\newrobustcmd*\option@addkeyinfo[1]{%
  \def\do##1##2##3{%
    \eifblank{##2}%
      {\option@setadd{##1/.names}{##3}
        \typeout{path "##1/.names": add "##3": \option{##1/.names}}%
      }%
      {\option@splitroot{##2}%
       \option@setadd{##1/.paths}{\option@root}%
       \typeout{path "##1/.paths": add "\option@root"; \option{##1/.paths}}%
      }%
  }
  \option@foreachparent{#1}%
}

% --------------------------------------------------------
% Basic definitions of options
% --------------------------------------------------------

\newrobustcmd*\newoptioncmd{\@ifstar{\newoptioncmd@{noarg}}{\newoptioncmd@{arg}}}
\newrobustcmd*\newoptioncmd@[3]{%*[]
  \typeout{define cmd: #2}%  
  \option@ensurefree{#2}%
  \option@splitkey{#2}% sets option@path, and option@name
  \eifblank{\option@path}{%
    \optionerror[#2]{no valid key name specified. Option definitions must start with a forward slash (i.e. "/path/<name>")}%
  }{}%
  \option@addkeyinfo{#2}%
  \csdef{optk@#2/.cmd}##1{%
    \typeout{invoke #2=##1 (\option@key=\option@value)}%
    \csuse{option@ensure#1}%
    \ifoptiondefined{#2/.cmdbefore}{\option{#2/.cmdbefore}}{}%
    #3%
    \ifoptiondefined{#2/.cmdafter}{\option{#2/.cmdafter}}{}%
    %\typeout{invoked}% 
  }%
  \csletcs{optk@#2}{optk@#2/.cmd}% point at first to the cmd
  \csuse{opt@parsedefault#1}{#2}%
}

\newrobustcmd*\newoptioncmdvalue[4]{%[]
  \newoptioncmd{#1}{#2}%
  \option@setkey{#1}{#3}%
  \option@setkey{#1/.initial}{#4}%
  \optionassign{#1}{#4}% this invokes the cmd the first time  
  \opt@parsedefaultarg{#1}%
}

\newrobustcmd*\newoptionvalue[2]{%[]
  \newoptioncmd{#1}{%
    %\typeout{assign value: #1=\option@value}%
    \option@letkey{#1}{\option@value}%
    %\typeout{assigned}
  }%
  \option@setkey{#1/.initial}{#2}%
  \optionassign{#1}{#2}% this invokes the cmd the first time  and assigns the initial value
  \opt@parsedefaultarg{#1}% set default value?
}


% --------------------------------------------------------
% Add pre/post processing to an option
% --------------------------------------------------------

\newrobustcmd*\addoptioncheck[2]{%
  \option@ensuredefined{#1}%
  \option@append{#1/.cmdbefore}{#2}%
}
\newrobustcmd*\addoptionexpand[1]{%
  \addoptioncheck{#1}{\protected@edef\option@value{\option@value}}%
}

\newrobustcmd*\addoptionsearch[2]{%
  \ifoptiondefined{#1/.searchalso}{}{%
    \option@setkey{optk@#1/.searchalso}{\typeout{search also: #1}}%
  }
  \def\do##1{%
    \edef\opt@temp{%
      \noexpand\ifx\noexpand\opt@trykey\noexpand\relax
        \noexpand\opt@searchforkey{##1/}{\noexpand\option@searchkey}%
      \noexpand\fi
    }%
    \expandnext{\option@append{#1/.searchalso}}{\opt@temp}%
  }
  \expandnext\docsvlist{#2}%
}

% --------------------------------------------------------
% Root definition
% --------------------------------------------------------


\newrobustcmd*\newoptionroot[1]{\@testopt{\newoptionroot@{#1}}{}}
\def\newoptionroot@#1[#2]{%
  \typeout{define root: #1: #2}%
  \option@appendlist{/.roots}{#1}%
  \newoptioncmd*{/#1}{\def\opt@defaultpath{/#1}}% the cmd for a root sets itself as the default root
  \option@esetkey{/#1/.delegates}{#2}%
  \option@setkey{/#1/.keys}{}%
  % define search for a key in this root (fully expanded for efficiency)
  \option@setkey{/#1/.search}{%
    \typeout{try (in root): /#1/\option@path}%
    \expandafter\let\expandafter\opt@trykey\csname optk@/#1/\option@path\endcsname
    \ifx\opt@trykey\relax
      % not found, invoke.searchalso
      \option{/#1/.searchalso}%
    \else%
      \typeout{ found!}%
      \edef\option@key{/#1/\option@path}%
    \fi    
  }%  
  % add sub-family searches (also expanded for efficiency)
  \option@setkey{/#1/.searchalso}{}%
  \def\do##1{%\option@search{#2}{##1}}
    \ifoptiondefined{/##1/.search}%
      {\option@append{/#1/.searchalso}{\ifx\opt@trykey\relax \option{/##1/.search}\fi}}%
      {\optionerror[#2]{definition "#2" refers to an unknown root "##1"}}%
  }%
  \expandafter\docsvlist\expandafter{#2}%
  % set further options
  %\newoptionstyle*{/#1/.only}{/.search=false,/#1}%
  %\newoptionstyle*{/#1/.only ignore}{/.ignore,/#1/.only}%
}


% --------------------------------------------------------
% Default handlers
% --------------------------------------------------------

\newrobustcmd*\optionerror[2][\option@key]{%
  \PackageError{options}{option "#1": #2}{}%
}

\newrobustcmd*\optionexpecterror[2][\option@key]{%
  \optionerror{unexpected "\option@value" (expecting #2)}%
}

\newoptioncmd{/.unknown}{%
  \let\opt@trykey\relax
  \eifblank{\option@unknownkey}{\def\option@unknownkey{?}}{}%
  \option@ifisabsolute{\option@unknownkey}%
    \optionerror[\option@unknownkey]{unknown option}
  \else
    \optionerror[\option@unknownkey]{unknown option under "\opt@defaultpath"}%
  \fi
}[]


\newoptioncmd*{/handlers/.cd}{%
  \typeout{cd to \option@handlerkey}%
  \edef\opt@defaultpath{\option@handlerkey}%
}


% --------------------------------------------------------
% Derived option definitions
% --------------------------------------------------------

\newrobustcmd*\newoptionstyle{\@ifstar{\newoptionstyle@{\newoptioncmd*}}{\newoptionstyle@{\newoptioncmd}}}%
\newrobustcmd*\newoptionstyle@[3]{%
  #1{#2}{\optionsetalso{#3}}%
}

\newrobustcmd*\newoptionif[2]{%
  \ifcsdef{if#2}{}{\optionerror[#1]{no `if` with name "#2" is defined}}%
  \newoptioncmd{#1}{%
    \ifcsdef{#2\option@value}%
      {\csuse{#2\option@value}}%
      {\optionexpecterror{a boolean value}}%
  }[true]%
}

\newrobustcmd*\newoptiontoggle[2]{%
  \newtoggle{#1}%
  \newoptioncmdvalue{#1}{%
    \ifcsdef{toggle\option@value}%
      {\csuse{toggle\option@value}{#1}}%
      {\optionexpecterror{a boolean value}}%
  }%
  {\iftoggle{#1}{true}{false}}% read value
  {#2}% initial assignment
  [true]%
}

\newrobustcmd*\newoptionchoice[2]{%  
  \newoptionvalue{#1}{\headof{#2}}%
  \addoptionexpand{#1}%
  \addoptioncheck{#1}{%
    \typeout{option choice: #1= \meaning##1, \meaning\option@value}%
    \eifanyof{\option@value}{#2}{}%
      {\optionexpecterror{one of "#2"}}%
  }
}


\newrobustcmd*\opt@showthe[1]{\the#1}%
\newrobustcmd*\newoptionlength[2]{%
  \csnewlength{#1}%
  \option@letkey{#1/.show}\opt@showthe
  \newoptioncmdvalue{#1}{%
    \typeout{set length: #1=\meaning\option@value}%
    \cssetlength{#1}{\dimexpr\option@value\relax}%
    \typeout{the length: #1=\the\csuse{#1}}%
  }%
  {\csuse{#1}}% read value
  {#2}% initial value
}

\newrobustcmd*\newoptiondimen[2]{%
  \newoptionvalue{#1}{\dimexpr#2\relax}%
  \addoptioncheck{#1}{\def\option@value{\dimexpr\option@value\relax}}%
  \option@letkey{#1/.show}\opt@showthe
}

% --------------------------------------------------------
% Initial handlers
% --------------------------------------------------------

\newoptionif{/.ignore}{opt@ignoreunknown}
\newoptionif{/.nosearch}{opt@nosearch}




% --------------------------------------------------------
% Show definitions
% --------------------------------------------------------

\newrobustcmd*\optionshowall[1][]{%
  \optionshowpath{#1}%
}

\newrobustcmd*\option@showname[1]{%
  \textsf{#1}%
}
\newrobustcmd*\option@showpathname[1]{%
  \textsf{#1}%
}

\newrobustcmd*\optionshowpath[2][]{%  
  \noindent\option@showpathname{#2/}%
  \ifoptionvoid{#1#2/.names}{}{\optionshownames{#1#2}{#1#2/.names}}%
  \ifoptionvoid{#1#2/.paths}{}{\optionshowpaths{#1#2}{#1#2/.paths}}%
}

\newrobustcmd*\optionshowpaths[3][]{%
  \begin{itemize}[noitemsep,topsep=0pt,leftmargin=1em,label=,#1]
  \def\do##1{%
    \item\optionshowpath[#2/]{##1}%
  }%
  \eletoption{#3}\opt@paths
  \optiondo{#3}%
  \end{itemize}
}

\newrobustcmd*\optionshownames[3][]{%
  \begin{itemize}[noitemsep,topsep=0pt,leftmargin=1em,label=,#1]
  \def\do##1{%
    \optionshowname{#2/##1}{##1}
  }%
  \optiondo{#3}%
  \end{itemize}
}


\newrobustcmd*\optionshowname[2]{%
  \item\option@showname{#2}%
  \ifoptiondefined{#1/.show}%
    {\letoption{#1/.show}\opt@showit}%
    {\def\opt@showit##1{##1}}%
  \def\opt@show##1{\textsf{\opt@showit{##1}}}%
  \expandafter\ifdefparam\expandafter{\csname optk@#1\endcsname}%
    {=\textit{cmd}}%
    {=\opt@show{\option{#1}}}%  
  \ifoptiondefined{#1/.initial}{%
    , initial=\opt@show{\option{#1/.initial}}%
  }{}%
  \ifoptiondefined{#1/.default}{%
    , default=\opt@show{\option{#1/.default}}%
  }{}%
}

\makeatother

\begin{document}


\makeatletter


%\newoptionroot{fama}

%\newoptionroot{famb}[fama]
%\newoptionroot{famc}[fama]
%\newoptionroot{fam}[famb,famc]

\newoptionstyle*{/fam}{/fam/.cd}
\addoptionsearch{/fam}{/famb,/fama}

\newoptioncmd{/fama/testa}{here is a=#1.}
\newoptioncmd{/famb/testb}{here is b=#1.}[defaultb]

\newoptiontoggle{/fama/toggle}{true}
\newoptionchoice{/famb/border/side}{top,left,right,bottom}

\newoptionlength{/fama/width}{\fboxrule + 1pt}
\newoptiondimen{/famb/widthb}{\fboxrule * 2 + 1pt}


\optionshowall


\the\option{/famb/widthb}

\option{/famb/border/side},

fboxrule=\the\dimexpr\fboxrule\relax,

\the\option{/famb/widthb},
\the\option{/fama/width}.

\fboxrule=1pt  it set

\the\option{/famb/widthb},
\the\option{/fama/width}.

\option{/famb/border/side},

\optionset{/fam,border/side=right,/fam/width=10pt} nice.

\option{/famb/border/side},

\optionshowall

\end{document}



\newrobustcmd*\test[1]{%
  \option@splitkey{#1}%
}

\test{/fam/key}
\test{/key}
\test{key}
\test{/.ignore}
\test{/fam/sub/key}
\test{/fam/sub/key/.ignore}
\test{}
\test{/}
\test{foo/key}
\test{//key}
\test{//fam/key}
\test{//}
\test{///}
\test{////key}
\end{document}

\end{document}

\option@findinkeypath{/fbox}{.unknown}
\option@findinkeypath{/fbox/}{.unknown}
\option@findinkeypath{/fbox/foo}{.unknown}
\option@findinkeypath{/fbox/border}{.unknown}
\option@findinkeypath{/fbox/border/left}{.unknown}
\option@findinkeypath{/fbox/border/left/width}{.unknown}
\option@findinkeypath{/fbox/xborder/left}{.unknown}
\option@findinkeypath{/fbox/xborder/left/width}{.unknown}
\option@findinkeypath{/}{.unknown}
\option@findinkeypath{/foo}{.unknown}
%\option@findinkeypath{}{.unknown}
\option@findinkeypath{/fbox/border/left/}{.unknown}
\option@findinkeypath{/fbox/border/left//}{.unknown}



\end{document}


\iftrue
\newcount\@loop
\def\opt@testforeach{%
  \option@foreachparent{/fbox/border/left/style}%
  \option@foreachparent{/fbox/border/left/style}%
  \option@foreachparent{/fbox/border/left/style}%
  \option@foreachparent{/fbox/border/left/style}%
  \option@foreachparent{/fbox/border/left/style}%
  \option@foreachparent{/fbox/border/left/style}%
  \option@foreachparent{/fbox/border/left/style}%
  \option@foreachparent{/fbox/border/left/style}%
  \option@foreachparent{/fbox/border/left/style}%
  \option@foreachparent{/fbox/border/left/style}%
  \option@foreachparent{/fbox/border/left/style}%
  \option@foreachparent{/fbox/border/left/style}%
  \advance\@loop 1\relax
}
\@whilenum\@loop<80000\do\opt@testforeach
\fi

\end{document}

